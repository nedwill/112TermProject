def calcAgenda(self,maxHours,maxDays=False,workDays=[0,1,2,3,4,5,6],workToday=True): #maxDays maximizes work in
    startDay = datetime.date.today()
    planTasks = [[] for day in xrange((self.latestTask - startDay).days+1)]
    planHours = [0]*((self.latestTask - startDay).days+1)
    self.assignments = sorted(self.assignments, key=lambda task: task.due)
    for task in self.fixed:
        daysAway = (task.due - startDay).days
        if len(task.recurring) > 0:
            for i in xrange(daysAway+1):
                dayOfWeek = datetime.date.weekday(datetime.date.today()+datetime.timedelta(i))
                if dayOfWeek not in task.recurring:
                    continue
                due = startDay + datetime.timedelta(i)
                startHour = datetime.time(task.startTime.hour)
                endHour = datetime.time(task.endTime.hour)
                startTime = datetime.datetime.combine(due,startHour)
                endTime = datetime.datetime.combine(due,endHour)
                #new = " " + str(startTime.hour) + ":" + "%02d" %
                #startTime.minute + "-" + str(endTime.hour) + ":" +
                #\"%02d" % endTime.minute
                choplength = len(str(task.startTime.hour) + \
                str(task.endTime.hour)) + 8 #4 extra chars #find length
                                            #to chop before recalling
                                            #constructor
                newtask = FixedTask(task.description[:-choplength],
                    startTime,endTime,True)
                if newtask.hours + planHours[i] <= maxHours:
                    planHours[i] += newtask.hours
                    planTasks[i] += [(newtask,newtask.hours)] #add tuple
                    #of task and hours allotted for that day
                else:
                    return None
        else:
            if task.hours + planHours[daysAway] <= maxHours:
                planHours[daysAway] += task.hours
                planTasks[daysAway] += [(task,task.hours)] #add tuple of
                #task and hours allotted for that day
            else:
                return None

            #workdays date.weekday()

    for i in xrange(len(self.assignments)): #cycle by index so we can
                                  #check if we're on the last element
        task = self.assignments[i]
        print task.description
        if task.due < datetime.date.today(): continue
        daysAway = (task.due - startDay).days #- 1 #index is days #-1 to finish a day in advance
                                                         #away from today
        hoursDone = task.hoursDone
        for day in xrange(daysAway+1):
            hoursLeft = task.hours - hoursDone
            if hoursLeft == 0:
                continue
            if day == 0 and workToday == False: continue
            dayOfWeek = datetime.date.weekday(datetime.date.today()+datetime.timedelta(day))
            if dayOfWeek not in workDays:
                if day == daysAway and hoursLeft != 0:
                    return None
                else:
                    continue
            daysLeft = (daysAway - day)
            weeksLeft = (daysLeft/7)
            workdaysremaining = 0
            for checkday in xrange(daysLeft):
                if (dayOfWeek + checkday) % 7 in workDays:
                    workdaysremaining += 1
            if workdaysremaining == 0: return None
            if workdaysremaining == 1:
                hoursPerDay = hoursLeft
            elif (i == (len(self.assignments) - 1) and maxDays == True):
                hoursPerDay = min(maxHours - planHours[day],hoursLeft)
            else:
                hoursPerDay = min(maxHours - planHours[day],int(math.ceil(float(hoursLeft)/(workdaysremaining))))
            if hoursPerDay == 0: continue
            if hoursPerDay + planHours[day] <= maxHours:
                hoursDone += hoursPerDay
                planHours[day] += hoursPerDay
                planTasks[day] += [(task,hoursPerDay)]
                #add tuple of task and hours allotted for that day
            elif day == daysAway:
                # if there are no days left, we can't
                # complete this assignment
                return None
    return planTasks