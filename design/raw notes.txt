These are my raw notes from the design process:

#model
	#all work can be represented in an array of tuples:
		# [("Task Name",dueDate,hoursToComplete) * tasks]
		# only basic array manipulation is required to add and remove tasks
	#work ordering algorithm factors:
		#weight based on time to deadline (nonlinear)
		#incorporate regular classes as a true day-to-day planner to be realistic
		#hours students wants to work (late-night, only during day, etc.)
		#plan out in advance through given waking hours, warn if schedule is impossible
		#lock/unlock toggle for day if desired so student can finish early or to
			#rearrange automatically based on human error
#view
	#text-based, transition to Tkinter once working using rows, cols representations of months
	#switch between months
	#show today's tasks and allow them to be checked off
	#functionality to add, edit, and remove new classes, homework, projects
	#agenda view
	#calendar 
#controller
	#keyboard input
	#mouse input with Tkinter implementation

#absolutely need to store data to be useful
#look at i/o functions

#http://www.doughellmann.com/PyMOTW/calendar/

#long term: online/cloud sync? MENU
#GUI
#PRINT
#efficiency based
#real time model w/ countdown
import calendar #application of below?
import datetime #really important

I expect by the end of Thanksgiving Break I will have at least a working model based on
my initial plan for the project: to have a calendar planning system that provides a more
intelligent approach to student work handling with an emphasis on early assignment completion.

More technically, the interface will have an overview calendar with a full daily agenda and
a summary of the upcoming workload (how many work hours per day are required to complete all
current assignments by their due dates) and a way to input new assignments alongside predetermined
classes, appointments, and other fixed responsibilities. Recurring tasks can also be included. Once
completed, they will not be reset until the next recurring period.

The user can set limitations on working times e.g. 9AM to 5PM or account for the whole day from
wakeup time to bedtime. In effect, this program will help build better work habits for students
through better planning in advance to avoid all-nighters.

In order for this program to be usable, it will require file I/O in order to maintain persistence
between program launches. Creating my own simple datafile should be fairly straightforward, but I
could expand my support to include some universal calendar formats for import and export between
another programs.

Libraries/modules to consider:
Tkinter
os
class structure w/ pickle
datetime
time

Possible ways to add complexity:
SIO schedule importation
Drag and Drop Reordering of Tasks
More impressive graphics that respond to user action.
Live timer to keep pace.
Google Calendar Import/Export/Sync
Universal Calendar file support import/export (.ical file)



c = calendar.TextCalendar(calendar.SUNDAY)
c.prmonth(2012, 11)

#planning todo:
#design full top-down model w/ functions/classes
#learn calendar class/module, understand calendar math
#learn datetime modules
#test functions

class setup:
Calendar
Task
	Recurring subclass
	Single time subclass
Graphics code in main


#print datetime.date.today().year #year
#print datetime.date.today().month #month
#print datetime.date.today().day #day

#daytest = datetime.date(2012,5,16)
#daytest2 = datetime.date.today()
#print (daytest2 - daytest).days
#print daytest

#print calendar.monthcalendar(2012,11) #critical!!!
#print calendar.monthcalendar(2012,12) #critical!!!

#to print the calendar, we have to get a list of each day in the month, figure out its length and starting point (monday = 0)
#and make a 2d list of the dates from the month. iterate through this and label each cell appropriately

#from datetime, use cass date(object), datetime(date), time, timedelta (all useful)
#check out calendar class in combination with datetime to process days
#these have methods to get the day of the week, other info

#print datetime.__doc__
#help(datetime)

#next:

#priority:
#fix overlapping fixed tasks, tasks with same names
#support minutes in hour timing - easy, just parse string for minutes and create the time objects to reflect the user's input


#graphics improvements - hover over task coloring and drag/drop
    #resizable w/ automatic ...s on tasks, calendar stuff
    #reset window dimensions button
    #better buttons
    #drawing calendar list past day
    #scrolling with buttons
#week view toggle

############## project due day 11 at 10PM

#done:
#finish calendar drawing with correct info for arbitrary calendars (datetime) #check!
#implement tasks completely with smart breaking up of tasks into agenda
#choose to fill all work hours vs. balancing it evenly -- currently it autosplits
#calc agenda
#process agenda in order of due dates not order added!!! -- while adding them, do a selection sort thing to accomplish this #check!
#click on a day on the map to select it, have the agenda show the selected day
#run calcAgenda to get that master list of tasks, draw the correct day based on the distance from today
#agenda menu: hours for that day, not total hours for task - make the planTasks list carry tuples of tasks and hours alloted to that day
#have init calculate the agenda itself and pass it to the Calendar and Agenda GraphicsElements - also have mousePressed do the same
#draw agenda description w/ hours to work onto individual days of the month
#adding tasks to agenda
    #have a unique identifier with the tasks - description?, check this when adding tasks
    #removeTask uses unique identifier to remove it and takes that identifier as an input (string?)
    #run calcAgenda and redraw everything after changing the tasklist
    #finally tie them to add and remove buttons that take user input

    #create parsed list with planned/updated info from datetime/deltatime
    #fixed tasks first, put tasks into list, keep track of hours filled for each day,
    #max hours each day limited by requirements given by user in CalendarPlanner
    #get task farthest in the future, create array for each day until then
    #run through fixedtasks and assign them to their times, adding hours into schedule (24 hour clock in programming mode, draw depending on user choice)
    #assign one task at a time into days, splitting evenly if day isn't filled until task hours are completed
#implement fixed, recurring tasks
#fixed are easy, they just have an extra time of day attribute to draw when doing the agenda
#for recurring, check the isRecurring flag (weekly/daily) and add it iteratively until we reach
#the max we determined earlier with the lastTask info - easy peasy
#save data to file, import data from file
#http://docs.python.org/2/library/pickle.html
#click gray box --> goes to next month

#export to ical file, google calendar
#https://developers.google.com/google-apps/calendar/firstapp
#algorithm:
# 1. link self.agendaCalc to a list of the days they're actually on. return list of datetimes corresponding to those days.
# 2. for every task in agendaCalc, create an event on the day given in the list we just calculated with the relevant information
# including the hours for that day in a calendar. if it's an assignment, no specific time. if it's a fixedtask, include the time
# once done adding to the cal object, save the file. prompt user for save info? http://code.activestate.com/recipes/438123-file-tkinter-dialogs/
# uploadable to google
#fixed recurring

#send text with selected agenda

#drag and drop - reassign assignment to new due date, modify all assignments - do this last because I don't really know what to do

#done today
#recurring drag and drop
#support minutes in hour timing - easy, just parse string for minutes and create the time objects to reflect the user's input
#graphics improvements - drag/drop
    #better button layout
    #drawing calendar list past day, same code for agenda


